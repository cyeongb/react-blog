let Post,mongoose;_f5b‍.x([["checkObjectId",()=>checkObjectId],["write",()=>write],["list",()=>list],["read",()=>read],["remove",()=>remove],["update",()=>update]]);_f5b‍.w("../../models/post",[["default",["Post"],function(v){Post=v}]]);_f5b‍.w("mongoose",[["default",["mongoose"],function(v){mongoose=v}]]);


// onject id를 검증 할 때 사용
const { ObjectId } = mongoose.Types; //type 속성으로 스키마를 가져온다

// 일일이 코드를 중복해 넣지 않고 '미들웨어' 로 만들어서 여러 라우트에 쉽게 적용할 수 있다.
       const checkObjectId = (ctx, next) => {
  console.log('id 검증 checkObjectId 호출! ');

  const { id } = ctx.params;
  _f5b‍.g.console.log('id >> ', id);

  if (!ObjectId.isValid(id)) {
    _f5b‍.g.console.log('id가 검증된 아이디인가? >>', ObjectId.isValid(id));

    ctx.status = 400; //bad request 잘못된 요청
    return;
  }
  _f5b‍.g.console.log('id가 검증된 아이디인가? >>', ObjectId.isValid(id));
  return next(); // id검증이 되면 그 다음 메서드를 실행한다.
};

// ----------------------------------------WRITE
// title:''/body:''/tags:['','']
       const write = async (ctx) => {
  const { title, body, tags } = ctx.request.body;

  const post = new Post({
    //post 의 인스턴스 생성
    title,
    body,
    tags,
  });

  try {
    console.log('posts.ctrl.js - write() 호출');
    log('title>>', title);
    await post.save(); // 인스턴스를 만들고 save() 함수를 실행시켜야 디비에 저장이 된다.
    // 함수의 반환값은 promise 이므로 async/await 문법으로 디비 저장 요청이 완료 될때 까지 await를 사용해서 대기할 수 있다.
    //그리고 await를 사용하려면 함수 선언 부분에 async 를 붙여야 한다. 그리고 try/catch 문으로 오류를 처리해야 한다.
    ctx.body = post;
  } catch (e) {
    _f5b‍.g.console.log('posts.ctrl.js - write error >>', e);
    ctx.throw(500, e); // 컨텍스트에 500 에러와 에러문을 던진다.
  }
};

// -------------------------------------- LIST
       const list = async (ctx) => {
  try {
    console.log('posts.ctrl.js - list() 호출');
    const posts = await Post.find().exec(); // find() 함수를 호출하고 나서 exec() 함수를 호출 해야 서버에 쿼리를 요청한다.
    _f5b‍.g.console.log('list 에 posts >>', posts);

    ctx.body = posts;
  } catch (e) {
    _f5b‍.g.console.log('posts.ctrl.js - list error >>', e);
    ctx.throw(500, e);
  }
};

// ---------------------------------------- READ
       const read = async (ctx) => {
  const { id } = ctx.params; //컨텍스트의 파라미터에 id값을 읽어온다.

  try {
    console.log('posts.ctrl.js - read() 호출');
    _f5b‍.g.console.log('id>>', id);
    const post = await Post.findById(id).exec();
    _f5b‍.g.console.log('read에 post >>', post);

    if (!post) {
      console.log('read -->post 없음');

      ctx.status = 404; //not found
      _f5b‍.g.console.log('ctx.status >>', ctx.status);

      return;
    }
  } catch (e) {
    _f5b‍.g.console.log('posts.ctrl.js - read error >>', e);
    ctx.throw(500, e);
  }
};

// ---------------------------------------- REMOVE
       const remove = async (ctx) => {
  const { id } = ctx.params;

  try {
    console.log('posts.ctrl.js - remove() 호출');
    _f5b‍.g.console.log('id >>', id);

    await Post.findByIdAndRemove(id).exec();
    ctx.status = 204; // 성공은 했지만 응답할 데이터가 없다.
  } catch (e) {
    _f5b‍.g.console.log('posts.ctrl.js - remove error >>', e);
    ctx.throw(500, e);
  }
};

// ------------------------------------------ UPDATE
       const update = async (ctx) => {
  const { id } = ctx.params;

  try {
    const post = await Post.findByIdAndUpdate(id, ctx.request.body, {
      new: true, // true 로 하면 업데이트된 후의 데이터를 반환한다. false는 업데이트 되기 전의 데이터를 반환한다.
    }).exec();
    console.log('posts.ctrl.js - update() 호출');
    _f5b‍.g.console.log('id >>', id);

    if (!post) {
      console.log('post 없음');
      ctx.status = 404;
      return;
    }
    ctx.body = post;
    _f5b‍.g.console.log('post>>', post);
  } catch (e) {
    _f5b‍.g.console.log('posts.ctrl.js - update error >>', e);
    ctx.throw(500, e);
  }
};
